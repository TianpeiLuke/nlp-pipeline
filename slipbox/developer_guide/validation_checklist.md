# Validation Checklist

Before integrating your new step into the pipeline, use this comprehensive checklist to validate your implementation. This will help catch common issues before they cause runtime failures.

## Script Implementation Validation

### Script Contract Integration

- [ ] **Path References**: Script uses paths from contract, not hardcoded paths
- [ ] **Environment Variables**: Script handles all required environment variables
- [ ] **Error Handling**: Script has comprehensive error handling and logging
- [ ] **Directory Creation**: Script creates output directories before writing files
- [ ] **Contract Import**: Script correctly imports and references its contract

### Script Code Quality

- [ ] **Entry Point**: Script has a clear entry point (e.g., `main()` function)
- [ ] **Modular Design**: Script is organized into well-defined functions
- [ ] **Type Hints**: Functions have appropriate type hints
- [ ] **Docstrings**: Functions have clear docstrings
- [ ] **Exception Handling**: Script catches and handles exceptions appropriately

### Script Path Handling

- [ ] **Directory vs. File**: Script correctly differentiates between directory and file paths
- [ ] **Path Construction**: Script uses `os.path.join()` for path construction
- [ ] **Path Existence Checks**: Script checks if input paths exist before reading
- [ ] **Output Directory Creation**: Script creates output directories before writing files
- [ ] **Parent Directory Handling**: Script handles parent directory creation for output files

## Script Contract Validation

### Contract Structure

- [ ] **Entry Point**: Contract specifies the correct script entry point
- [ ] **Input Paths**: Contract includes all input paths used by the script
- [ ] **Output Paths**: Contract includes all output paths generated by the script
- [ ] **Environment Variables**: Contract declares all environment variables used by the script
- [ ] **Optional Variables**: Contract includes default values for optional variables

### Path Conventions

- [ ] **SageMaker Convention**: Contract follows SageMaker path conventions:
  - Processing inputs: `/opt/ml/processing/input/{logical_name}`
  - Processing outputs: `/opt/ml/processing/output/{logical_name}`
  - Training inputs: `/opt/ml/input/data/{channel_name}`
  - Model outputs: `/opt/ml/model`
- [ ] **Path Separation**: Input and output paths are separate (no overlapping)
- [ ] **Directory Paths**: Output paths for files use parent directories to avoid SageMaker directory creation issues

### Logical Name Consistency

- [ ] **Descriptive Names**: Contract uses descriptive logical names
- [ ] **Consistent Naming**: Naming follows project conventions
- [ ] **Script Alignment**: Logical names match those used in the script
- [ ] **Specification Alignment**: Logical names align with specification dependencies and outputs

## Step Specification Validation

### Basic Structure

- [ ] **Step Type**: Specification uses the correct step type from registry
- [ ] **Node Type**: Specification has the appropriate node type (SOURCE, INTERNAL, or SINK)
- [ ] **Script Contract**: Specification references the correct script contract
- [ ] **Dependencies**: Dependencies match the script's input requirements
- [ ] **Outputs**: Outputs match the script's output generation

### NodeType Consistency

- [ ] **SOURCE Node**: No dependencies if node type is SOURCE
- [ ] **SINK Node**: No outputs if node type is SINK
- [ ] **INTERNAL Node**: Both dependencies and outputs if node type is INTERNAL

### Dependency Specifications

- [ ] **Logical Names**: Dependency logical names match contract input paths
- [ ] **Required Status**: Required status is correctly specified
- [ ] **Compatible Sources**: All possible compatible sources are listed
- [ ] **Dependency Type**: Dependency type matches upstream output type
- [ ] **Semantic Keywords**: Rich semantic keywords are provided
- [ ] **Data Type**: Data type is specified
- [ ] **Description**: Clear description is provided

### Output Specifications

- [ ] **Logical Names**: Output logical names match contract output paths
- [ ] **Output Type**: Output type is correctly specified
- [ ] **Property Path Format**: Property path follows the standard format:
  - For processing outputs: `properties.ProcessingOutputConfig.Outputs['logical_name'].S3Output.S3Uri`
  - For model artifacts: `properties.ModelArtifacts.S3ModelArtifacts`
- [ ] **Aliases**: Useful aliases are provided if needed
- [ ] **Data Type**: Data type is specified
- [ ] **Description**: Clear description is provided

### Contract Alignment

- [ ] **Input Alignment**: Dependencies match contract input paths
- [ ] **Output Alignment**: Outputs match contract output paths
- [ ] **Validation Passes**: `validate_contract_alignment()` returns success

## Step Builder Validation

### Builder Structure

- [ ] **Base Class**: Builder extends the appropriate base class
- [ ] **Config Type**: Builder is parameterized with the correct config type
- [ ] **Specification**: Builder uses the correct specification
- [ ] **Job Type Handling**: Builder handles job type variants if needed
- [ ] **Method Overrides**: Builder overrides necessary methods

### Input/Output Handling

- [ ] **Specification-Driven**: Builder uses specification-driven methods for inputs/outputs
- [ ] **Contract Paths**: Builder uses paths from the contract via specification
- [ ] **Dependency Extraction**: Builder correctly extracts inputs from dependencies
- [ ] **Input Mapping**: Input names match dependency logical names
- [ ] **Output Mapping**: Output names match output logical names

### Environment Variable Handling

- [ ] **Contract Variables**: Builder sets all environment variables required by the contract
- [ ] **Type Conversion**: Non-string values are converted to strings
- [ ] **Required Variables**: All required variables are set
- [ ] **Optional Variables**: Optional variables have defaults
- [ ] **Config Mapping**: Variables are mapped from configuration

### Resource Configuration

- [ ] **Instance Type**: Appropriate instance type is configured
- [ ] **Instance Count**: Appropriate instance count is configured
- [ ] **Volume Size**: Appropriate volume size is configured
- [ ] **Max Runtime**: Appropriate max runtime is configured
- [ ] **Image URI**: Correct image URI is provided

## Step Registration Validation

### Registry Updates

- [ ] **Step Names**: Step is registered in `step_names.py`
- [ ] **Config Class**: Config class name is registered correctly
- [ ] **Builder Class**: Builder class name is registered correctly
- [ ] **Spec Type**: Specification type is registered correctly
- [ ] **Description**: Clear description is provided

### Import Updates

- [ ] **Builder Import**: Builder is imported in `pipeline_steps/__init__.py`
- [ ] **Specification Import**: Specification is imported in `pipeline_step_specs/__init__.py`
- [ ] **Contract Import**: Contract is imported in `pipeline_script_contracts/__init__.py`
- [ ] **Config Import**: Config is imported appropriately

## Pipeline Integration Validation

### DAG Integration

- [ ] **Node Addition**: Step is added to the DAG
- [ ] **Edge Connections**: Step is connected with appropriate edges
- [ ] **Topological Order**: DAG maintains valid topological order
- [ ] **Configuration**: Step configuration is added to the config map
- [ ] **Builder Map**: Step builder is added to the builder map

### Dependency Compatibility

- [ ] **Input Type Matching**: Step input types match upstream output types
- [ ] **Dependency Resolution**: Dependencies can be resolved from upstream steps
- [ ] **Optional Dependencies**: Optional dependencies are handled correctly
- [ ] **Semantic Matching**: Semantic matching works correctly

## Testing Validation

### Unit Tests

- [ ] **Builder Tests**: Tests for the step builder
- [ ] **Specification Tests**: Tests for the step specification
- [ ] **Contract Tests**: Tests for the script contract
- [ ] **Script Tests**: Tests for the script functionality

### Test Coverage

- [ ] **Contract Alignment**: Tests for contract-specification alignment
- [ ] **Property Paths**: Tests for property path consistency
- [ ] **Environment Variables**: Tests for environment variable generation
- [ ] **Input Generation**: Tests for input generation
- [ ] **Output Generation**: Tests for output generation

### Edge Case Testing

- [ ] **Missing Dependencies**: Tests for missing optional dependencies
- [ ] **Job Type Variants**: Tests for different job types
- [ ] **Error Handling**: Tests for error conditions
- [ ] **Empty Inputs**: Tests with empty inputs
- [ ] **Large Inputs**: Tests with large inputs if applicable

### Integration Testing

- [ ] **End-to-End Test**: End-to-end test with the step in a pipeline
- [ ] **Cross-Step Compatibility**: Tests for compatibility with connected steps
- [ ] **Dependency Resolution**: Tests for dependency resolution
- [ ] **DAG Validation**: Tests for DAG validation

## Documentation Validation

### Code Documentation

- [ ] **Class Docstrings**: All classes have docstrings
- [ ] **Method Docstrings**: All methods have docstrings
- [ ] **Parameter Documentation**: All parameters are documented
- [ ] **Return Documentation**: All return values are documented
- [ ] **Exception Documentation**: Exceptions are documented

### External Documentation

- [ ] **Step Description**: Step is described in appropriate documentation
- [ ] **Usage Examples**: Usage examples are provided
- [ ] **Configuration Documentation**: Configuration options are documented
- [ ] **Integration Guide**: Integration guide is updated
- [ ] **README Updates**: READMEs are updated if necessary

## Final Verification

### Automated Checks

- [ ] **Contract Validation**: Run `validate_contracts.py` tool
- [ ] **Step Name Validation**: Run `validate_step_names.py` tool
- [ ] **Unit Tests**: Run all unit tests
- [ ] **Integration Tests**: Run integration tests
- [ ] **Linting**: Run linters

### Manual Checks

- [ ] **Code Review**: Get code reviewed by another developer
- [ ] **Pipeline Test**: Test the step in an actual pipeline
- [ ] **Documentation Review**: Review documentation for completeness
- [ ] **Configuration Review**: Review configuration for sensible defaults
- [ ] **Error Message Review**: Review error messages for clarity

## Contract-to-Specification Alignment Verification

To assist with verifying alignment between script contracts and step specifications, use this command:

```python
from src.v2.pipeline_step_specs.your_step_spec import YOUR_STEP_SPEC

# Validate alignment
result = YOUR_STEP_SPEC.validate_contract_alignment()
print(f"Is valid: {result.is_valid}")
if not result.is_valid:
    print("Errors:")
    for error in result.errors:
        print(f"- {error}")
```

## Property Path Consistency Verification

To check property path consistency in outputs:

```python
from src.v2.pipeline_step_specs.your_step_spec import YOUR_STEP_SPEC

# Check property paths
for output_name, output_spec in YOUR_STEP_SPEC.outputs.items():
    expected = f"properties.ProcessingOutputConfig.Outputs['{output_spec.logical_name}'].S3Output.S3Uri"
    if output_spec.output_type == DependencyType.PROCESSING_OUTPUT and output_spec.property_path != expected:
        print(f"Property path inconsistency in {output_name}")
        print(f"  Expected: {expected}")
        print(f"  Actual: {output_spec.property_path}")
```

## Environment Variable Validation

To check environment variables:

```python
from src.v2.pipeline_steps.builder_your_step import YourStepBuilder
from src.v2.pipeline_steps.config_your_step import YourStepConfig

# Create config and builder
config = YourStepConfig(
    region="us-west-2",
    pipeline_s3_loc="s3://bucket/prefix"
)
builder = YourStepBuilder(config)

# Check environment variables
env_vars = builder._get_processor_env_vars()
required_vars = builder.spec.script_contract.required_env_vars

# Check all required variables are present
missing_vars = [var for var in required_vars if var not in env_vars]
if missing_vars:
    print(f"Missing environment variables: {missing_vars}")
else:
    print("All required environment variables are present")
```

By using this checklist, you can identify and fix issues before integrating your step into the pipeline, leading to more robust and reliable implementations.
